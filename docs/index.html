<!DOCTYPE html>
<html>
    <head>
        <link rel="stylesheet" href="styles.css">
        <style>
        html, body {
            width: 100%;
            height: 100%;
            margin: 0px;
            border: 0;
            overflow: hidden; /*  Disable scrollbars */
            display: block;  /* No floating content on sides */
        }
        </style>
    </head>
    <body>
        <button id="start">Start</button>
        <button id="stop">Stop</button>
        <canvas id = "canvas" width = "1200" height = "600"></canvas>
        <div id="filter_modal" class="modal">
            <div class="modal-content">
              <span class="close" onclick="closeModal()">&times;</span>
              <p>Set the cutoff frequency</p>
              <b>0</b><input type = "range" min = '0' max = '22050' id = 'lowpass_slider' value = 5500></input> <b>22050</b>
              <p id = "lowpass_label">Lowpass Cutoff: 5500</p>
            </div>
          
        </div> 
        <div id="duration_modal" class="modal">
        <div class="modal-content">
            <span id = "close_duration" class="close" onclick="closeModal()">&times;</span>
            <p>Set duration (ms)</p>
            <b>1</b><input type = "range" min = '1' max = '1000' id = 'duration_slider' value = 100></input> <b>1000</b>
            <p id = "duration_label">Duration: 100 ms</p>
        </div>

    </body>
</html>


<script src = "ocanvas-2.10.0.js"></script>
<script>

    //globals

    const defaults = {
        lowpass: 5500,
        duration: .01,
        gain: 0.8
    };

    const noiseTypes = {
        WHITE: "white noise",
        CONSTANT: "constant"
    }

    // canvas
    var currModal = document.getElementById("duration_modal");

    var canvas = oCanvas.create({
        canvas: "#canvas",
        background: "#ccc"
    });

    var nodeProto = canvas.display.rectangle({
        origin: { x: "center", y: "center" },
        height: 50,
        fill: "#079",
        stroke: "10px #079",
        join: "round"
    });

    var nodeLabelProto = canvas.display.text({
        x: 0,
        y: 0,
        align: "center",
        origin: {x: "center", y: 25},
        font: "bold 25px sans-serif",
        fill: "#fff"
    });

    var nodeSubtextProto = canvas.display.text({
        x: 0,
        y: 15,
        origin: { x: "center", y: "center" },
        align: "center",
        font: "18px sans-serif",
        fill: "#fff"
    });

    var audioNodes = {};
    var durationNodes = {};
    var currNode = null;
    // var currNodeType;
    var dragged = false;
    
    function createNode(options, audioNode, modalType) {

        var node = nodeProto.clone({
            width: options.width,
            x: options.x,
            y: options.y
        });

        node.next = [];
        node.audioNode = options.audioNode;

        var label = nodeLabelProto.clone({
            text: options.labeltext,
            
        });

        var subtext = nodeSubtextProto.clone({
            text: options.subtext,
        });
        
        function openModal() {
            if(dragged) {
                dragged = false;
            }
            else {
                currNode = node.id; 
                if(modalType !== "none") {
                    currModal = document.getElementById(modalType);
                    currModal.style.display = "block";
                }
            }
        }

        node.bind("click tap", openModal);
        node.dragAndDrop({ changeZindex: true, move: function(){dragged = true; }});
        node.addChild(label);
        node.addChild(subtext);
        canvas.addChild(node);
        audioNodes[node.id] = audioNode;
        return node;
    }

    function connect(n1, n2) {
        n1.next.push(n2);
        n1.audioNode.connect(n2.audioNode);
        // drawLineBetween(n1, n2);
    }

    function drawLineBetween(n1, n2) {

    }

    

    // Audio init
    
    var audioCtx = new AudioContext();

    var freq = defaults.frequency;
    var pluckBuffer = new AudioBuffer({numberOfChannels: 1, length: audioCtx.sampleRate * defaults.duration, sampleRate: audioCtx.sampleRate});
    
    
    var buffer = pluckBuffer.getChannelData(0);

    function generateNoise(buffer, noiseType) {
        for(var i = 0; i < buffer.length; i++) {
        switch(noiseType) {
            case noiseTypes.WHITE:
                buffer[i] = Math.random() * 2 - 1;
                break;
            case noiseTypes.CONSTANT:
                buffer[i] = 1;
                break;
        }
         // generate white noise sample
        // buffer[i] = 1;
        }
    }
    
    
    var delay = new DelayNode(audioCtx, {delayTime: defaults.duration});
    var gain = new GainNode(audioCtx, {gain: 2 * defaults.gain});
    var filter = new BiquadFilterNode(audioCtx, {type: 'lowpass', frequency: defaults.lowpass, Q: 0});
    var merge = new ChannelMergerNode(audioCtx, {numberOfInputs: 2});
    var split = new ChannelSplitterNode(audioCtx, {numberOfOutputs: 2});


    var sourceBufferNode = createNode({width: 200, x: 150, y: 30, labeltext: "Source Buffer", subtext: "type: white noise"}, pluckBuffer, "none");
    var mergeNode = createNode({width: 100, x: 350, y: 30, labeltext: "Merge", subtext: ""}, merge, "none");
    var splitNode = createNode({width: 100, x: 600, y: 30, labeltext: "Split", subtext: ""}, split, "none");
    var delayNode = createNode({width: 200, x: 500, y: 150, labeltext: "Delay Node", subtext: "Delay = "}, delay, "duration_modal");
    var filterNode = createNode({width: 200, x: 250, y: 150, labeltext: "Lowpass Filter", subtext: "cutoff: "}, filter, "filter_modal");
    var gainNode = createNode({width: 100, x: 700, y: 150, labeltext: "Gain", subtext: ""}, gain, "none");
    var destNode = createNode({width: 150, x: 850, y: 30, labeltext: "Destination", subtext: "", }, audioCtx.destination, "none");

    // connect(mergeNode, delayNode);
    // connect(delayNode, gainNode);

    merge.connect(gain);
    gain.connect(delay);
    delay.connect(filter);
    filter.connect(merge);
    merge.connect(split);
    split.connect(audioCtx.destination);

    // merge.connect(split);
    // split.connect(gain);
    // split.connect(audioCtx.destination);
    // gain.connect(delay);
    // delay.connect(filter);
    // filter.connect(merge);

    const lowpass_slider = document.getElementById('lowpass_slider');
    const duration_slider = document.getElementById('duration_slider');

    lowpass_slider.onchange = function() {
        document.getElementById("lowpass_label").innerHTML = "Lowpass Cutoff: " + lowpass_slider.value;
        audioNodes[currNode].frequency.setValueAtTime(lowpass_slider.value, audioCtx.currentTime);
    }
        
    duration_slider.onchange = function() {
        document.getElementById("duration_label").innerHTML = "Duration: " + duration_slider.value + " ms";
        audioNodes[currNode].delayTime.setValueAtTime(duration_slider.value / 1000, audioCtx.currentTime);
    }

    window.onclick = function(event) {
        if (event.target == currModal) {
            closeModal();
        }
    }

    function closeModal() {
        currModal.style.display = "none";
    }
   
    const startButton = document.getElementById("start");
    const stopButton = document.getElementById("stop");
    start.onclick = function() {

        var pluckBuffer = new AudioBuffer({numberOfChannels: 1, length: audioCtx.sampleRate * defaults.duration, sampleRate: audioCtx.sampleRate});
        buffer = pluckBuffer.getChannelData(0);
        for(var i = 0; i < buffer.length; i++) {
            //switch()
            buffer[i] = Math.random() * 2 - 1; // generate white noise sample
            // buffer[i] = 1;
        }

        audioCtx.resume();
        var pluckSource = new AudioBufferSourceNode(audioCtx, {buffer: pluckBuffer}); // creates a source to play the pluck buffer from 
        pluckSource.connect(merge);
        pluckSource.start();

        setTimeout(() => {
            pluckSource.stop(); 
            pluckSource.disconnect(merge);
            },
            1000);
    }


    // function stop() {
    //     pluckSource.disconnect();
    //     merge.disconnect();
    //     delay.disconnect();
    //     gain.disconnect();
    //     filter.disconnect();
    //     split.disconnect();
        //pluckSource.stop();  
    // }

    // stopButton.onclick = stop();
    
    
    
</script>